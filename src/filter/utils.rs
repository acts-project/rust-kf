use nalgebra as na;
use super::super::config::*;
use super::super::geometry::traits::{Plane, Transform};

#[macro_use]
use super::macros;

/// Placeholder function for some form of effective seeding for Mat5's
pub fn seed_covariance() -> Mat5 {
    // create a matrix with every element being .1
    let mut base = Mat5::zeros();
    base.fill(0.1);

    let id = Mat5::identity();

    return base + id;

}

/// Calculate the first filtered state vector estimate based on the 
/// global starting position of the particle and the the location
/// of the sensor it is supposed to hit

// NOTE: this function is basically a wrapper around `seed_state_vec_from_points` 
//          for ease of writing tests
pub fn seed_state_vec_from_sensor<T: Plane + Transform>(
    start_location: &P3, 
    first_sensor: &T
    ) -> Vec5 {

    let global_end = first_sensor.global_center();
    let local_end = first_sensor.to_local(*global_end);     // TODO store local_center so we dont need this conversion

    seed_state_vec_from_points(&start_location, &global_end, &local_end)

}


/// Calculate the first filtered state vector based on global point starting position,
/// local ending location, and global ending location
pub fn seed_state_vec_from_points(
    global_start_location: &P3,
    global_destination: &P3,
    local_destination: &P2
    ) -> Vec5{

    // position vector from begining point to ending point
    let vector_to_sensor = global_destination - global_start_location;

    // fetch local hit measurements
    get_unchecked!{vector; vector_to_sensor;
        eLOC_0 => x,
        eLOC_1 => y
    }

    let z_axis = Vec3::new(0., 0., 1.);
    let x_axis = Vec3::new(1., 0., 0.);

    // on the XY projection we construct, if we are in quadrants 3 or 4 then the angle
    // generated by .angle() will be x instead of 2pi - x (returns smallest angle between vectors). 
    // we do this here to reduce copies.
    let adjust_factor = 
        if y < &0. {true}
        else {false};

    let xy_projection = Vec3::new(*x, *y, 0.);

    let _phi = xy_projection.angle(&x_axis);

    // if we are in quadrants 3/4 we need to adjust for the angle in _phi
    let phi = 
        if adjust_factor{ (2. * PI) - _phi }
        else{ _phi };

    let theta = vector_to_sensor.angle(&z_axis);
    
    let mut seed_vec = Vec5::zeros();

    change_mat_val!{seed_vec;
        [eLOC_0,0] => local_destination.x,
        [eLOC_1,0] => local_destination.y,
        [ePHI,0]   => phi,
        [eTHETA,0] => theta,
        [eQOP, 0] => 1.
    }

    seed_vec
}



/// Creates a vector of `num` length with Mat5 components
pub fn vec_of_mat(num: usize) -> Vec<Mat5> {
    
    let mut return_vec: Vec<Mat5> = Vec::with_capacity(num);
    (0..num).into_iter()
        .for_each(|_| return_vec.push(seed_covariance()));
    
    return return_vec
}

/// Creates a vector of `num` length with Vec5 components
pub fn vec_of_vec(num: usize) -> Vec<Vec5> {
    
    let mut return_vec: Vec<Vec5> = Vec::with_capacity(num);
    (0..num).into_iter()
        .for_each(|_| return_vec.push(Vec5::new_random()));
    
    return return_vec
}

#[derive(Debug)]
pub struct SmoothedData {
    pub state_vec: Vec<Vec5>,
    pub cov_mat: Vec<Mat5>,
    pub res_mat: Vec<Mat2>,
    pub res_vec: Vec<Vec2>
}

impl SmoothedData{
    pub fn new(state_vec: Vec<Vec5>,
            cov_mat: Vec<Mat5>,
            res_mat: Vec<Mat2>,
            res_vec: Vec<Vec2>) -> Self {

        return SmoothedData{state_vec: state_vec, 
                            cov_mat: cov_mat, 
                            res_mat: res_mat, 
                            res_vec:res_vec}
    }
    pub fn FFI_return() {
        unimplemented!()
    }
}

#[derive(Debug)]
pub struct PredictedData {
    pub state_vec: Vec<Vec5>,
    pub cov_mat: Vec<Mat5>,
    pub res_mat: Vec<Mat2>,
    pub res_vec: Vec<Vec2>
}

impl PredictedData{
    pub fn new(state_vec: Vec<Vec5>,
            cov_mat: Vec<Mat5>,
            res_mat: Vec<Mat2>,
            res_vec: Vec<Vec2>) -> Self {

        return PredictedData{state_vec: state_vec, 
                            cov_mat: cov_mat, 
                            res_mat: res_mat, 
                            res_vec:res_vec}
    }
}

#[derive(Debug)]
pub struct FilteredData {
    pub state_vec: Vec<Vec5>,
    pub cov_mat: Vec<Mat5>,
    pub res_mat: Vec<Mat2>,
    pub res_vec: Vec<Vec2>
}

impl FilteredData{
    pub fn new(state_vec: Vec<Vec5>,
            cov_mat: Vec<Mat5>,
            res_mat: Vec<Mat2>,
            res_vec: Vec<Vec2>) -> Self {

        return FilteredData{state_vec: state_vec, 
                            cov_mat: cov_mat, 
                            res_mat: res_mat, 
                            res_vec:res_vec}
    }
}


pub struct Data{
    pub smth: SmoothedData,
    pub filt: FilteredData,
    pub pred: PredictedData
}
impl Data{
    pub fn new(smth: SmoothedData, filt: FilteredData, pred: PredictedData) -> Self{
        Data{
            smth: smth,
            filt: filt,
            pred: pred
        }
    }
}